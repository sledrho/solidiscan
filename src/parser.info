-----------------------------------------------------------------------------
Info file generated by Happy Version 1.19.5 from parser.y
-----------------------------------------------------------------------------


rule 8 is unused
rule 21 is unused
rule 22 is unused
rule 25 is unused
rule 26 is unused
rule 27 is unused
rule 28 is unused
rule 29 is unused

terminal "reservedid" is unused
terminal "decimalnum" is unused
terminal "exponent" is unused
terminal "int" is unused
terminal "string" is unused
terminal "address" is unused
terminal "bool" is unused
terminal "var" is unused
terminal "true" is unused
terminal "false" is unused
terminal "^" is unused
terminal "!" is unused
terminal "&&" is unused
terminal "||" is unused
terminal "!=" is unused
terminal "<" is unused
terminal ">" is unused
terminal "<=" is unused
terminal ">=" is unused
terminal "==" is unused
terminal "[" is unused
terminal "]" is unused
terminal "." is unused
terminal "*" is unused
terminal "/" is unused
terminal "**" is unused
terminal "%" is unused
terminal op is unused
terminal "-" is unused
terminal "(" is unused
terminal ")" is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_solidiscan -> SourceUnit                    (0)
	SourceUnit ->                                      (1)
	SourceUnit -> SourceUnit SourceUnitSol             (2)
	SourceUnitSol -> PragmaDirective                   (3)
	SourceUnitSol -> ImportDirective                   (4)
	SourceUnitSol -> ContractDefinition                (5)
	PragmaDirective -> "pragma" PragmaName version ";"   (6)
	PragmaName -> ident                                (7)
	PragmaValue -> "decimalnum"                        (8)
	ImportDirective -> "import" stringLiteral ";"      (9)
	ContractDefinition -> contract ident "{" list(ContractPart) "}"   (10)
	ContractPart -> StateVarDec                        (11)
	ContractPart -> FunctionDefinition                 (12)
	FunctionDefinition -> function ident Parameter ";"   (13)
	Parameter -> ident                                 (14)
	StateVarDec -> TypeName zero(AssVar) ident zero(MExpression) ";"   (15)
	TypeName -> ident                                  (16)
	AssVar -> "public"                                 (17)
	AssVar -> "private"                                (18)
	AssVar -> "internal"                               (19)
	AssVar -> "constant"                               (20)
	MaybeExp -> MExpression                            (21)
	MaybeExp ->                                        (22)
	MExpression -> "=" Expression                      (23)
	Expression -> ident                                (24)
	UserDefinedTypeName -> ident                       (25)
	ElementaryTypeName -> "address"                    (26)
	ElementaryTypeName -> "bool"                       (27)
	ElementaryTypeName -> "var"                        (28)
	ElementaryTypeName -> "string"                     (29)
	list(ContractPart) -> list1(ContractPart)          (30)
	list(ContractPart) ->                              (31)
	zero(AssVar) -> AssVar                             (32)
	zero(AssVar) ->                                    (33)
	zero(MExpression) -> MExpression                   (34)
	zero(MExpression) ->                               (35)
	list1(ContractPart) -> ContractPart                (36)
	list1(ContractPart) -> ContractPart list1(ContractPart)   (37)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	"reservedid"   { TReservedOp _ }
	version        { TVers _ }
	"decimalnum"   { TDec _ $$ }
	"exponent"     { TExp _ $$ }
	"int"          { TInt _ $$ }
	"pragma"       { TPragma _ }
	"import"       { TImport _ }
	"public"       { TPublic _ $$ }
	"internal"     { TIntern _ $$ }
	"private"      { TPriv _ $$ }
	"constant"     { TConst _ $$ }
	"string"       { TStringAs _ $$ }
	contract       { TContract _ }
	function       { TFuncDef _ }
	"address"      { TAddr _ $$ }
	"bool"         { TBooleanLit _ $$ }
	"var"          { TVar _ $$ }
	"true"         { TTrue _ }
	"false"        { TFalse _ }
	"^"            { THat _ }
	"!"            { TNegate _ }
	"&&"           { TAnd _ }
	"||"           { TOr _ }
	"!="           { TInEqual _ }
	"<"            { TLThan _ }
	">"            { TGThan _ }
	"<="           { TLTEq _ }
	">="           { TGTEq _ }
	"=="           { TEquality _ }
	"{"            { TLCurl _ }
	"}"            { TRCurl _ }
	"["            { TLBrack _ }
	"]"            { TRBrack _ }
	"."            { TPeriod _ }
	"="            { TEquals _ }
	"*"            { TMult _ }
	"/"            { TDiv _ }
	"**"           { TExpSym _ }
	"%"            { TModul _ }
	op             { TOp _ $$ }
	"-"            { TSub _ }
	";"            { TSemiCol _ }
	ident          { TIdent _ $$ }
	stringLiteral  { TStringLiteral _ $$ }
	"("            { TLeftParen _ }
	")"            { TRightParen _ }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_solidiscan rule  0
	SourceUnit      rules 1, 2
	SourceUnitSol   rules 3, 4, 5
	PragmaDirective rule  6
	PragmaName      rule  7
	PragmaValue     rule  8
	ImportDirective rule  9
	ContractDefinition rule  10
	ContractPart    rules 11, 12
	FunctionDefinition rule  13
	Parameter       rule  14
	StateVarDec     rule  15
	TypeName        rule  16
	AssVar          rules 17, 18, 19, 20
	MaybeExp        rules 21, 22
	MExpression     rule  23
	Expression      rule  24
	UserDefinedTypeName rule  25
	ElementaryTypeName rules 26, 27, 28, 29
	list(ContractPart) rules 30, 31
	zero(AssVar)    rules 32, 33
	zero(MExpression) rules 34, 35
	list1(ContractPart) rules 36, 37

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0


	"pragma"       reduce using rule 1
	"import"       reduce using rule 1
	contract       reduce using rule 1
	%eof           reduce using rule 1

	SourceUnit     goto state 2

State 1




State 2

	%start_solidiscan -> SourceUnit .                   (rule 0)
	SourceUnit -> SourceUnit . SourceUnitSol            (rule 2)

	"pragma"       shift, and enter state 7
	"import"       shift, and enter state 8
	contract       shift, and enter state 9
	%eof           accept

	SourceUnitSol  goto state 3
	PragmaDirectivegoto state 4
	ImportDirectivegoto state 5
	ContractDefinitiongoto state 6

State 3

	SourceUnit -> SourceUnit SourceUnitSol .            (rule 2)

	"pragma"       reduce using rule 2
	"import"       reduce using rule 2
	contract       reduce using rule 2
	%eof           reduce using rule 2


State 4

	SourceUnitSol -> PragmaDirective .                  (rule 3)

	"pragma"       reduce using rule 3
	"import"       reduce using rule 3
	contract       reduce using rule 3
	%eof           reduce using rule 3


State 5

	SourceUnitSol -> ImportDirective .                  (rule 4)

	"pragma"       reduce using rule 4
	"import"       reduce using rule 4
	contract       reduce using rule 4
	%eof           reduce using rule 4


State 6

	SourceUnitSol -> ContractDefinition .               (rule 5)

	"pragma"       reduce using rule 5
	"import"       reduce using rule 5
	contract       reduce using rule 5
	%eof           reduce using rule 5


State 7

	PragmaDirective -> "pragma" . PragmaName version ";"    (rule 6)

	ident          shift, and enter state 13

	PragmaName     goto state 12

State 8

	ImportDirective -> "import" . stringLiteral ";"     (rule 9)

	stringLiteral  shift, and enter state 11


State 9

	ContractDefinition -> contract . ident "{" list(ContractPart) "}"    (rule 10)

	ident          shift, and enter state 10


State 10

	ContractDefinition -> contract ident . "{" list(ContractPart) "}"    (rule 10)

	"{"            shift, and enter state 16


State 11

	ImportDirective -> "import" stringLiteral . ";"     (rule 9)

	";"            shift, and enter state 15


State 12

	PragmaDirective -> "pragma" PragmaName . version ";"    (rule 6)

	version        shift, and enter state 14


State 13

	PragmaName -> ident .                               (rule 7)

	version        reduce using rule 7


State 14

	PragmaDirective -> "pragma" PragmaName version . ";"    (rule 6)

	";"            shift, and enter state 25


State 15

	ImportDirective -> "import" stringLiteral ";" .     (rule 9)

	"pragma"       reduce using rule 9
	"import"       reduce using rule 9
	contract       reduce using rule 9
	%eof           reduce using rule 9


State 16

	ContractDefinition -> contract ident "{" . list(ContractPart) "}"    (rule 10)

	function       shift, and enter state 23
	"}"            reduce using rule 31
	ident          shift, and enter state 24

	ContractPart   goto state 17
	FunctionDefinitiongoto state 18
	StateVarDec    goto state 19
	TypeName       goto state 20
	list(ContractPart)goto state 21
	list1(ContractPart)goto state 22

State 17

	list1(ContractPart) -> ContractPart .               (rule 36)
	list1(ContractPart) -> ContractPart . list1(ContractPart)    (rule 37)

	function       shift, and enter state 23
	"}"            reduce using rule 36
	ident          shift, and enter state 24

	ContractPart   goto state 17
	FunctionDefinitiongoto state 18
	StateVarDec    goto state 19
	TypeName       goto state 20
	list1(ContractPart)goto state 34

State 18

	ContractPart -> FunctionDefinition .                (rule 12)

	function       reduce using rule 12
	"}"            reduce using rule 12
	ident          reduce using rule 12


State 19

	ContractPart -> StateVarDec .                       (rule 11)

	function       reduce using rule 11
	"}"            reduce using rule 11
	ident          reduce using rule 11


State 20

	StateVarDec -> TypeName . zero(AssVar) ident zero(MExpression) ";"    (rule 15)

	"public"       shift, and enter state 30
	"internal"     shift, and enter state 31
	"private"      shift, and enter state 32
	"constant"     shift, and enter state 33
	ident          reduce using rule 33

	AssVar         goto state 28
	zero(AssVar)   goto state 29

State 21

	ContractDefinition -> contract ident "{" list(ContractPart) . "}"    (rule 10)

	"}"            shift, and enter state 27


State 22

	list(ContractPart) -> list1(ContractPart) .         (rule 30)

	"}"            reduce using rule 30


State 23

	FunctionDefinition -> function . ident Parameter ";"    (rule 13)

	ident          shift, and enter state 26


State 24

	TypeName -> ident .                                 (rule 16)

	"public"       reduce using rule 16
	"internal"     reduce using rule 16
	"private"      reduce using rule 16
	"constant"     reduce using rule 16
	ident          reduce using rule 16


State 25

	PragmaDirective -> "pragma" PragmaName version ";" .    (rule 6)

	"pragma"       reduce using rule 6
	"import"       reduce using rule 6
	contract       reduce using rule 6
	%eof           reduce using rule 6


State 26

	FunctionDefinition -> function ident . Parameter ";"    (rule 13)

	ident          shift, and enter state 37

	Parameter      goto state 36

State 27

	ContractDefinition -> contract ident "{" list(ContractPart) "}" .    (rule 10)

	"pragma"       reduce using rule 10
	"import"       reduce using rule 10
	contract       reduce using rule 10
	%eof           reduce using rule 10


State 28

	zero(AssVar) -> AssVar .                            (rule 32)

	ident          reduce using rule 32


State 29

	StateVarDec -> TypeName zero(AssVar) . ident zero(MExpression) ";"    (rule 15)

	ident          shift, and enter state 35


State 30

	AssVar -> "public" .                                (rule 17)

	ident          reduce using rule 17


State 31

	AssVar -> "internal" .                              (rule 19)

	ident          reduce using rule 19


State 32

	AssVar -> "private" .                               (rule 18)

	ident          reduce using rule 18


State 33

	AssVar -> "constant" .                              (rule 20)

	ident          reduce using rule 20


State 34

	list1(ContractPart) -> ContractPart list1(ContractPart) .    (rule 37)

	"}"            reduce using rule 37


State 35

	StateVarDec -> TypeName zero(AssVar) ident . zero(MExpression) ";"    (rule 15)

	"="            shift, and enter state 41
	";"            reduce using rule 35

	MExpression    goto state 39
	zero(MExpression)goto state 40

State 36

	FunctionDefinition -> function ident Parameter . ";"    (rule 13)

	";"            shift, and enter state 38


State 37

	Parameter -> ident .                                (rule 14)

	";"            reduce using rule 14


State 38

	FunctionDefinition -> function ident Parameter ";" .    (rule 13)

	function       reduce using rule 13
	"}"            reduce using rule 13
	ident          reduce using rule 13


State 39

	zero(MExpression) -> MExpression .                  (rule 34)

	";"            reduce using rule 34


State 40

	StateVarDec -> TypeName zero(AssVar) ident zero(MExpression) . ";"    (rule 15)

	";"            shift, and enter state 44


State 41

	MExpression -> "=" . Expression                     (rule 23)

	ident          shift, and enter state 43

	Expression     goto state 42

State 42

	MExpression -> "=" Expression .                     (rule 23)

	";"            reduce using rule 23


State 43

	Expression -> ident .                               (rule 24)

	";"            reduce using rule 24


State 44

	StateVarDec -> TypeName zero(AssVar) ident zero(MExpression) ";" .    (rule 15)

	function       reduce using rule 15
	"}"            reduce using rule 15
	ident          reduce using rule 15


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 38
Number of terminals: 46
Number of non-terminals: 23
Number of states: 45
