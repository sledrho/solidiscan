-----------------------------------------------------------------------------
Info file generated by Happy Version 1.19.5 from parser.y
-----------------------------------------------------------------------------

state 29 contains 1 shift/reduce conflicts.

rule 8 is unused
rule 16 is unused
rule 17 is unused
rule 19 is unused
rule 20 is unused
rule 25 is unused
rule 26 is unused
rule 27 is unused
rule 28 is unused
rule 31 is unused

terminal "reservedid" is unused
terminal "decimalnum" is unused
terminal "exponent" is unused
terminal "int" is unused
terminal "public" is unused
terminal "internal" is unused
terminal "private" is unused
terminal "constant" is unused
terminal "string" is unused
terminal "address" is unused
terminal "bool" is unused
terminal "var" is unused
terminal "true" is unused
terminal "false" is unused
terminal "^" is unused
terminal "!" is unused
terminal "&&" is unused
terminal "||" is unused
terminal "!=" is unused
terminal "<" is unused
terminal ">" is unused
terminal "<=" is unused
terminal ">=" is unused
terminal "==" is unused
terminal "[" is unused
terminal "]" is unused
terminal "." is unused
terminal "*" is unused
terminal "/" is unused
terminal "**" is unused
terminal "%" is unused
terminal op is unused
terminal "-" is unused
terminal "(" is unused
terminal ")" is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_solidiscan -> SourceUnit                    (0)
	SourceUnit ->                                      (1)
	SourceUnit -> SourceUnit SourceUnitSol             (2)
	SourceUnitSol -> PragmaDirective                   (3)
	SourceUnitSol -> ImportDirective                   (4)
	SourceUnitSol -> ContractDefinition                (5)
	PragmaDirective -> "pragma" PragmaName version ";"   (6)
	PragmaName -> ident                                (7)
	PragmaValue -> "decimalnum"                        (8)
	ImportDirective -> "import" stringLiteral ";"      (9)
	ContractDefinition -> contract ident "{" list(ContractPart) "}"   (10)
	ContractPart -> StateVarDec                        (11)
	ContractPart -> FunctionDefinition                 (12)
	FunctionDefinition -> function ident Parameter ";"   (13)
	Parameter -> ident                                 (14)
	StateVarDec -> TypeName multi(AssVar) ident zero(MExpression) ";"   (15)
	AssVarL -> AssVar                                  (16)
	AssVarL -> AssVarL AssVar                          (17)
	AssVar -> ident                                    (18)
	MaybeExp -> MExpression                            (19)
	MaybeExp ->                                        (20)
	MExpression -> "=" Expression                      (21)
	Expression -> ident                                (22)
	TypeName -> UserDefinedTypeName                    (23)
	UserDefinedTypeName -> ident                       (24)
	ElementaryTypeName -> "address"                    (25)
	ElementaryTypeName -> "bool"                       (26)
	ElementaryTypeName -> "var"                        (27)
	ElementaryTypeName -> "string"                     (28)
	list(ContractPart) -> list1(ContractPart)          (29)
	list(ContractPart) ->                              (30)
	multi(AssVar) -> AssVar                            (31)
	multi(AssVar) -> AssVar multi(AssVar)              (32)
	zero(MExpression) -> MExpression                   (33)
	zero(MExpression) ->                               (34)
	list1(ContractPart) -> ContractPart                (35)
	list1(ContractPart) -> ContractPart list1(ContractPart)   (36)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	"reservedid"   { TReservedOp _ }
	version        { TVers _ }
	"decimalnum"   { TDec _ $$ }
	"exponent"     { TExp _ $$ }
	"int"          { TInt _ $$ }
	"pragma"       { TPragma _ }
	"import"       { TImport _ }
	"public"       { TPublic _ }
	"internal"     { TIntern _ }
	"private"      { TPriv _ }
	"constant"     { TConst _ }
	"string"       { TStringAs _ }
	contract       { TContract _ }
	function       { TFuncDef _ }
	"address"      { TAddr _ }
	"bool"         { TBooleanLit _ }
	"var"          { TVar _ }
	"true"         { TTrue _ }
	"false"        { TFalse _ }
	"^"            { THat _ }
	"!"            { TNegate _ }
	"&&"           { TAnd _ }
	"||"           { TOr _ }
	"!="           { TInEqual _ }
	"<"            { TLThan _ }
	">"            { TGThan _ }
	"<="           { TLTEq _ }
	">="           { TGTEq _ }
	"=="           { TEquality _ }
	"{"            { TLCurl _ }
	"}"            { TRCurl _ }
	"["            { TLBrack _ }
	"]"            { TRBrack _ }
	"."            { TPeriod _ }
	"="            { TEquals _ }
	"*"            { TMult _ }
	"/"            { TDiv _ }
	"**"           { TExpSym _ }
	"%"            { TModul _ }
	op             { TOp _ $$ }
	"-"            { TSub _ }
	";"            { TSemiCol _ }
	ident          { TIdent _ $$ }
	stringLiteral  { TStringLiteral _ $$ }
	"("            { TLeftParen _ }
	")"            { TRightParen _ }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_solidiscan rule  0
	SourceUnit      rules 1, 2
	SourceUnitSol   rules 3, 4, 5
	PragmaDirective rule  6
	PragmaName      rule  7
	PragmaValue     rule  8
	ImportDirective rule  9
	ContractDefinition rule  10
	ContractPart    rules 11, 12
	FunctionDefinition rule  13
	Parameter       rule  14
	StateVarDec     rule  15
	AssVarL         rules 16, 17
	AssVar          rule  18
	MaybeExp        rules 19, 20
	MExpression     rule  21
	Expression      rule  22
	TypeName        rule  23
	UserDefinedTypeName rule  24
	ElementaryTypeName rules 25, 26, 27, 28
	list(ContractPart) rules 29, 30
	multi(AssVar)   rules 31, 32
	zero(MExpression) rules 33, 34
	list1(ContractPart) rules 35, 36

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0


	"pragma"       reduce using rule 1
	"import"       reduce using rule 1
	contract       reduce using rule 1
	%eof           reduce using rule 1

	SourceUnit     goto state 2

State 1




State 2

	%start_solidiscan -> SourceUnit .                   (rule 0)
	SourceUnit -> SourceUnit . SourceUnitSol            (rule 2)

	"pragma"       shift, and enter state 7
	"import"       shift, and enter state 8
	contract       shift, and enter state 9
	%eof           accept

	SourceUnitSol  goto state 3
	PragmaDirectivegoto state 4
	ImportDirectivegoto state 5
	ContractDefinitiongoto state 6

State 3

	SourceUnit -> SourceUnit SourceUnitSol .            (rule 2)

	"pragma"       reduce using rule 2
	"import"       reduce using rule 2
	contract       reduce using rule 2
	%eof           reduce using rule 2


State 4

	SourceUnitSol -> PragmaDirective .                  (rule 3)

	"pragma"       reduce using rule 3
	"import"       reduce using rule 3
	contract       reduce using rule 3
	%eof           reduce using rule 3


State 5

	SourceUnitSol -> ImportDirective .                  (rule 4)

	"pragma"       reduce using rule 4
	"import"       reduce using rule 4
	contract       reduce using rule 4
	%eof           reduce using rule 4


State 6

	SourceUnitSol -> ContractDefinition .               (rule 5)

	"pragma"       reduce using rule 5
	"import"       reduce using rule 5
	contract       reduce using rule 5
	%eof           reduce using rule 5


State 7

	PragmaDirective -> "pragma" . PragmaName version ";"    (rule 6)

	ident          shift, and enter state 13

	PragmaName     goto state 12

State 8

	ImportDirective -> "import" . stringLiteral ";"     (rule 9)

	stringLiteral  shift, and enter state 11


State 9

	ContractDefinition -> contract . ident "{" list(ContractPart) "}"    (rule 10)

	ident          shift, and enter state 10


State 10

	ContractDefinition -> contract ident . "{" list(ContractPart) "}"    (rule 10)

	"{"            shift, and enter state 16


State 11

	ImportDirective -> "import" stringLiteral . ";"     (rule 9)

	";"            shift, and enter state 15


State 12

	PragmaDirective -> "pragma" PragmaName . version ";"    (rule 6)

	version        shift, and enter state 14


State 13

	PragmaName -> ident .                               (rule 7)

	version        reduce using rule 7


State 14

	PragmaDirective -> "pragma" PragmaName version . ";"    (rule 6)

	";"            shift, and enter state 26


State 15

	ImportDirective -> "import" stringLiteral ";" .     (rule 9)

	"pragma"       reduce using rule 9
	"import"       reduce using rule 9
	contract       reduce using rule 9
	%eof           reduce using rule 9


State 16

	ContractDefinition -> contract ident "{" . list(ContractPart) "}"    (rule 10)

	function       shift, and enter state 24
	"}"            reduce using rule 30
	ident          shift, and enter state 25

	ContractPart   goto state 17
	FunctionDefinitiongoto state 18
	StateVarDec    goto state 19
	TypeName       goto state 20
	UserDefinedTypeNamegoto state 21
	list(ContractPart)goto state 22
	list1(ContractPart)goto state 23

State 17

	list1(ContractPart) -> ContractPart .               (rule 35)
	list1(ContractPart) -> ContractPart . list1(ContractPart)    (rule 36)

	function       shift, and enter state 24
	"}"            reduce using rule 35
	ident          shift, and enter state 25

	ContractPart   goto state 17
	FunctionDefinitiongoto state 18
	StateVarDec    goto state 19
	TypeName       goto state 20
	UserDefinedTypeNamegoto state 21
	list1(ContractPart)goto state 32

State 18

	ContractPart -> FunctionDefinition .                (rule 12)

	function       reduce using rule 12
	"}"            reduce using rule 12
	ident          reduce using rule 12


State 19

	ContractPart -> StateVarDec .                       (rule 11)

	function       reduce using rule 11
	"}"            reduce using rule 11
	ident          reduce using rule 11


State 20

	StateVarDec -> TypeName . multi(AssVar) ident zero(MExpression) ";"    (rule 15)

	ident          shift, and enter state 31

	AssVar         goto state 29
	multi(AssVar)  goto state 30

State 21

	TypeName -> UserDefinedTypeName .                   (rule 23)

	ident          reduce using rule 23


State 22

	ContractDefinition -> contract ident "{" list(ContractPart) . "}"    (rule 10)

	"}"            shift, and enter state 28


State 23

	list(ContractPart) -> list1(ContractPart) .         (rule 29)

	"}"            reduce using rule 29


State 24

	FunctionDefinition -> function . ident Parameter ";"    (rule 13)

	ident          shift, and enter state 27


State 25

	UserDefinedTypeName -> ident .                      (rule 24)

	ident          reduce using rule 24


State 26

	PragmaDirective -> "pragma" PragmaName version ";" .    (rule 6)

	"pragma"       reduce using rule 6
	"import"       reduce using rule 6
	contract       reduce using rule 6
	%eof           reduce using rule 6


State 27

	FunctionDefinition -> function ident . Parameter ";"    (rule 13)

	ident          shift, and enter state 36

	Parameter      goto state 35

State 28

	ContractDefinition -> contract ident "{" list(ContractPart) "}" .    (rule 10)

	"pragma"       reduce using rule 10
	"import"       reduce using rule 10
	contract       reduce using rule 10
	%eof           reduce using rule 10


State 29

	multi(AssVar) -> AssVar .                           (rule 31)
	multi(AssVar) -> AssVar . multi(AssVar)             (rule 32)

	ident          shift, and enter state 31
			(reduce using rule 31)


	AssVar         goto state 29
	multi(AssVar)  goto state 34

State 30

	StateVarDec -> TypeName multi(AssVar) . ident zero(MExpression) ";"    (rule 15)

	ident          shift, and enter state 33


State 31

	AssVar -> ident .                                   (rule 18)

	ident          reduce using rule 18


State 32

	list1(ContractPart) -> ContractPart list1(ContractPart) .    (rule 36)

	"}"            reduce using rule 36


State 33

	StateVarDec -> TypeName multi(AssVar) ident . zero(MExpression) ";"    (rule 15)

	"="            shift, and enter state 40
	";"            reduce using rule 34

	MExpression    goto state 38
	zero(MExpression)goto state 39

State 34

	multi(AssVar) -> AssVar multi(AssVar) .             (rule 32)

	ident          reduce using rule 32


State 35

	FunctionDefinition -> function ident Parameter . ";"    (rule 13)

	";"            shift, and enter state 37


State 36

	Parameter -> ident .                                (rule 14)

	";"            reduce using rule 14


State 37

	FunctionDefinition -> function ident Parameter ";" .    (rule 13)

	function       reduce using rule 13
	"}"            reduce using rule 13
	ident          reduce using rule 13


State 38

	zero(MExpression) -> MExpression .                  (rule 33)

	";"            reduce using rule 33


State 39

	StateVarDec -> TypeName multi(AssVar) ident zero(MExpression) . ";"    (rule 15)

	";"            shift, and enter state 43


State 40

	MExpression -> "=" . Expression                     (rule 21)

	ident          shift, and enter state 42

	Expression     goto state 41

State 41

	MExpression -> "=" Expression .                     (rule 21)

	";"            reduce using rule 21


State 42

	Expression -> ident .                               (rule 22)

	";"            reduce using rule 22


State 43

	StateVarDec -> TypeName multi(AssVar) ident zero(MExpression) ";" .    (rule 15)

	function       reduce using rule 15
	"}"            reduce using rule 15
	ident          reduce using rule 15


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 37
Number of terminals: 46
Number of non-terminals: 24
Number of states: 44
