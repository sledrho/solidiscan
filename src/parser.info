-----------------------------------------------------------------------------
Info file generated by Happy Version 1.19.5 from parser.y
-----------------------------------------------------------------------------


rule 21 is unused
rule 22 is unused
rule 34 is unused
rule 35 is unused
rule 50 is unused
rule 51 is unused

terminal "reservedid" is unused
terminal "decimalnum" is unused
terminal "exponent" is unused
terminal "int" is unused
terminal "^" is unused
terminal "!" is unused
terminal "&&" is unused
terminal "||" is unused
terminal "!=" is unused
terminal "<" is unused
terminal ">" is unused
terminal "<=" is unused
terminal ">=" is unused
terminal "==" is unused
terminal "[" is unused
terminal "]" is unused
terminal "." is unused
terminal "/" is unused
terminal "**" is unused
terminal "%" is unused
terminal op is unused
terminal "-" is unused
terminal "(" is unused
terminal ")" is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_solidiscan -> SourceUnit                    (0)
	SourceUnit ->                                      (1)
	SourceUnit -> SourceUnit SourceUnitSol             (2)
	SourceUnitSol -> PragmaDirective                   (3)
	SourceUnitSol -> ImportDirective                   (4)
	SourceUnitSol -> ContractDefinition                (5)
	PragmaDirective -> "pragma" PragmaName version ";"   (6)
	PragmaName -> ident                                (7)
	ImportDirective -> "import" stringLiteral ImportAs ";"   (8)
	ImportDirective -> "import" ImportAster ImportAs "from" stringLiteral ";"   (9)
	ImportAs -> "as" ident                             (10)
	ImportAs ->                                        (11)
	ImportAster -> "*"                                 (12)
	ImportAster -> ident                               (13)
	ContractDefinition -> ConLibInt ident zero(InheritanceSpecList) "{" list(ContractPart) "}"   (14)
	ConLibInt -> contract                              (15)
	ConLibInt -> "library"                             (16)
	ConLibInt -> "interface"                           (17)
	InheritanceSpecList -> "is" InheritanceSpecifier list(OMInheritanceSpec)   (18)
	OMInheritanceSpec -> "," InheritanceSpecifier      (19)
	InheritanceSpecifier -> UserDefinedTypeName        (20)
	InhExpList -> "(" Expression multi(CSExpList) ")"   (21)
	CSExpList -> "," Expression                        (22)
	ContractPart -> StateVarDec                        (23)
	ContractPart -> FunctionDefinition                 (24)
	FunctionDefinition -> function ident Parameter ";"   (25)
	Parameter -> ident                                 (26)
	StateVarDec -> TypeName zero(AssVar) ident zero(MExpression) ";"   (27)
	TypeName -> ElementaryTypeName                     (28)
	TypeName -> UserDefinedTypeName                    (29)
	AssVar -> "public"                                 (30)
	AssVar -> "private"                                (31)
	AssVar -> "internal"                               (32)
	AssVar -> "constant"                               (33)
	MaybeExp -> MExpression                            (34)
	MaybeExp ->                                        (35)
	MExpression -> "=" Expression                      (36)
	Expression -> PrimaryExpression                    (37)
	PrimaryExpression -> BooleanLiteral                (38)
	BooleanLiteral -> "true"                           (39)
	BooleanLiteral -> "false"                          (40)
	UserDefinedTypeName -> ident                       (41)
	ElementaryTypeName -> "address"                    (42)
	ElementaryTypeName -> "bool"                       (43)
	ElementaryTypeName -> "var"                        (44)
	ElementaryTypeName -> "string"                     (45)
	list(ContractPart) -> list1(ContractPart)          (46)
	list(ContractPart) ->                              (47)
	list(OMInheritanceSpec) -> list1(OMInheritanceSpec)   (48)
	list(OMInheritanceSpec) ->                         (49)
	multi(CSExpList) -> CSExpList                      (50)
	multi(CSExpList) -> CSExpList multi(CSExpList)     (51)
	zero(AssVar) -> AssVar                             (52)
	zero(AssVar) ->                                    (53)
	zero(InheritanceSpecList) -> InheritanceSpecList   (54)
	zero(InheritanceSpecList) ->                       (55)
	zero(MExpression) -> MExpression                   (56)
	zero(MExpression) ->                               (57)
	list1(ContractPart) -> ContractPart                (58)
	list1(ContractPart) -> ContractPart list1(ContractPart)   (59)
	list1(OMInheritanceSpec) -> OMInheritanceSpec      (60)
	list1(OMInheritanceSpec) -> OMInheritanceSpec list1(OMInheritanceSpec)   (61)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	"reservedid"   { TReservedOp _ }
	version        { TVers _ }
	"decimalnum"   { TDec _ $$ }
	"exponent"     { TExp _ $$ }
	"int"          { TInt _ $$ }
	"pragma"       { TPragma _ }
	"import"       { TImport _ }
	"public"       { TPublic _ $$ }
	"internal"     { TIntern _ $$ }
	"private"      { TPriv _ $$ }
	"constant"     { TConst _ $$ }
	"string"       { TStringAs _ $$ }
	contract       { TContract _ }
	"library"      { TLibrary _ }
	"interface"    { TInterface _ }
	function       { TFuncDef _ }
	"address"      { TAddr _ $$ }
	"bool"         { TBooleanLit _ $$ }
	"var"          { TVar _ $$ }
	"true"         { TTrue _ }
	"false"        { TFalse _ }
	"as"           { TAs _ }
	"is"           { TIs _ }
	"from"         { TFrom _ }
	"^"            { THat _ }
	"!"            { TNegate _ }
	"&&"           { TAnd _ }
	"||"           { TOr _ }
	"!="           { TInEqual _ }
	"<"            { TLThan _ }
	">"            { TGThan _ }
	"<="           { TLTEq _ }
	">="           { TGTEq _ }
	"=="           { TEquality _ }
	"{"            { TLCurl _ }
	"}"            { TRCurl _ }
	"["            { TLBrack _ }
	"]"            { TRBrack _ }
	"."            { TPeriod _ }
	"="            { TEquals _ }
	"*"            { TMult _ }
	"/"            { TDiv _ }
	"**"           { TExpSym _ }
	"%"            { TModul _ }
	op             { TOp _ $$ }
	"-"            { TSub _ }
	";"            { TSemiCol _ }
	","            { TComma _ }
	ident          { TIdent _ $$ }
	stringLiteral  { TStringLiteral _ $$ }
	"("            { TLeftParen _ }
	")"            { TRightParen _ }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_solidiscan rule  0
	SourceUnit      rules 1, 2
	SourceUnitSol   rules 3, 4, 5
	PragmaDirective rule  6
	PragmaName      rule  7
	ImportDirective rules 8, 9
	ImportAs        rules 10, 11
	ImportAster     rules 12, 13
	ContractDefinition rule  14
	ConLibInt       rules 15, 16, 17
	InheritanceSpecList rule  18
	OMInheritanceSpec rule  19
	InheritanceSpecifier rule  20
	InhExpList      rule  21
	CSExpList       rule  22
	ContractPart    rules 23, 24
	FunctionDefinition rule  25
	Parameter       rule  26
	StateVarDec     rule  27
	TypeName        rules 28, 29
	AssVar          rules 30, 31, 32, 33
	MaybeExp        rules 34, 35
	MExpression     rule  36
	Expression      rule  37
	PrimaryExpression rule  38
	BooleanLiteral  rules 39, 40
	UserDefinedTypeName rule  41
	ElementaryTypeName rules 42, 43, 44, 45
	list(ContractPart) rules 46, 47
	list(OMInheritanceSpec) rules 48, 49
	multi(CSExpList) rules 50, 51
	zero(AssVar)    rules 52, 53
	zero(InheritanceSpecList) rules 54, 55
	zero(MExpression) rules 56, 57
	list1(ContractPart) rules 58, 59
	list1(OMInheritanceSpec) rules 60, 61

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0


	"pragma"       reduce using rule 1
	"import"       reduce using rule 1
	contract       reduce using rule 1
	"library"      reduce using rule 1
	"interface"    reduce using rule 1
	%eof           reduce using rule 1

	SourceUnit     goto state 2

State 1




State 2

	%start_solidiscan -> SourceUnit .                   (rule 0)
	SourceUnit -> SourceUnit . SourceUnitSol            (rule 2)

	"pragma"       shift, and enter state 8
	"import"       shift, and enter state 9
	contract       shift, and enter state 10
	"library"      shift, and enter state 11
	"interface"    shift, and enter state 12
	%eof           accept

	SourceUnitSol  goto state 3
	PragmaDirectivegoto state 4
	ImportDirectivegoto state 5
	ContractDefinitiongoto state 6
	ConLibInt      goto state 7

State 3

	SourceUnit -> SourceUnit SourceUnitSol .            (rule 2)

	"pragma"       reduce using rule 2
	"import"       reduce using rule 2
	contract       reduce using rule 2
	"library"      reduce using rule 2
	"interface"    reduce using rule 2
	%eof           reduce using rule 2


State 4

	SourceUnitSol -> PragmaDirective .                  (rule 3)

	"pragma"       reduce using rule 3
	"import"       reduce using rule 3
	contract       reduce using rule 3
	"library"      reduce using rule 3
	"interface"    reduce using rule 3
	%eof           reduce using rule 3


State 5

	SourceUnitSol -> ImportDirective .                  (rule 4)

	"pragma"       reduce using rule 4
	"import"       reduce using rule 4
	contract       reduce using rule 4
	"library"      reduce using rule 4
	"interface"    reduce using rule 4
	%eof           reduce using rule 4


State 6

	SourceUnitSol -> ContractDefinition .               (rule 5)

	"pragma"       reduce using rule 5
	"import"       reduce using rule 5
	contract       reduce using rule 5
	"library"      reduce using rule 5
	"interface"    reduce using rule 5
	%eof           reduce using rule 5


State 7

	ContractDefinition -> ConLibInt . ident zero(InheritanceSpecList) "{" list(ContractPart) "}"    (rule 14)

	ident          shift, and enter state 19


State 8

	PragmaDirective -> "pragma" . PragmaName version ";"    (rule 6)

	ident          shift, and enter state 18

	PragmaName     goto state 17

State 9

	ImportDirective -> "import" . stringLiteral ImportAs ";"    (rule 8)
	ImportDirective -> "import" . ImportAster ImportAs "from" stringLiteral ";"    (rule 9)

	"*"            shift, and enter state 14
	ident          shift, and enter state 15
	stringLiteral  shift, and enter state 16

	ImportAster    goto state 13

State 10

	ConLibInt -> contract .                             (rule 15)

	ident          reduce using rule 15


State 11

	ConLibInt -> "library" .                            (rule 16)

	ident          reduce using rule 16


State 12

	ConLibInt -> "interface" .                          (rule 17)

	ident          reduce using rule 17


State 13

	ImportDirective -> "import" ImportAster . ImportAs "from" stringLiteral ";"    (rule 9)

	"as"           shift, and enter state 25
	"from"         reduce using rule 11

	ImportAs       goto state 26

State 14

	ImportAster -> "*" .                                (rule 12)

	"as"           reduce using rule 12
	"from"         reduce using rule 12


State 15

	ImportAster -> ident .                              (rule 13)

	"as"           reduce using rule 13
	"from"         reduce using rule 13


State 16

	ImportDirective -> "import" stringLiteral . ImportAs ";"    (rule 8)

	"as"           shift, and enter state 25
	";"            reduce using rule 11

	ImportAs       goto state 24

State 17

	PragmaDirective -> "pragma" PragmaName . version ";"    (rule 6)

	version        shift, and enter state 23


State 18

	PragmaName -> ident .                               (rule 7)

	version        reduce using rule 7


State 19

	ContractDefinition -> ConLibInt ident . zero(InheritanceSpecList) "{" list(ContractPart) "}"    (rule 14)

	"is"           shift, and enter state 22
	"{"            reduce using rule 55

	InheritanceSpecListgoto state 20
	zero(InheritanceSpecList)goto state 21

State 20

	zero(InheritanceSpecList) -> InheritanceSpecList .    (rule 54)

	"{"            reduce using rule 54


State 21

	ContractDefinition -> ConLibInt ident zero(InheritanceSpecList) . "{" list(ContractPart) "}"    (rule 14)

	"{"            shift, and enter state 34


State 22

	InheritanceSpecList -> "is" . InheritanceSpecifier list(OMInheritanceSpec)    (rule 18)

	ident          shift, and enter state 33

	InheritanceSpecifiergoto state 31
	UserDefinedTypeNamegoto state 32

State 23

	PragmaDirective -> "pragma" PragmaName version . ";"    (rule 6)

	";"            shift, and enter state 30


State 24

	ImportDirective -> "import" stringLiteral ImportAs . ";"    (rule 8)

	";"            shift, and enter state 29


State 25

	ImportAs -> "as" . ident                            (rule 10)

	ident          shift, and enter state 28


State 26

	ImportDirective -> "import" ImportAster ImportAs . "from" stringLiteral ";"    (rule 9)

	"from"         shift, and enter state 27


State 27

	ImportDirective -> "import" ImportAster ImportAs "from" . stringLiteral ";"    (rule 9)

	stringLiteral  shift, and enter state 52


State 28

	ImportAs -> "as" ident .                            (rule 10)

	"from"         reduce using rule 10
	";"            reduce using rule 10


State 29

	ImportDirective -> "import" stringLiteral ImportAs ";" .    (rule 8)

	"pragma"       reduce using rule 8
	"import"       reduce using rule 8
	contract       reduce using rule 8
	"library"      reduce using rule 8
	"interface"    reduce using rule 8
	%eof           reduce using rule 8


State 30

	PragmaDirective -> "pragma" PragmaName version ";" .    (rule 6)

	"pragma"       reduce using rule 6
	"import"       reduce using rule 6
	contract       reduce using rule 6
	"library"      reduce using rule 6
	"interface"    reduce using rule 6
	%eof           reduce using rule 6


State 31

	InheritanceSpecList -> "is" InheritanceSpecifier . list(OMInheritanceSpec)    (rule 18)

	"{"            reduce using rule 49
	","            shift, and enter state 51

	OMInheritanceSpecgoto state 48
	list(OMInheritanceSpec)goto state 49
	list1(OMInheritanceSpec)goto state 50

State 32

	InheritanceSpecifier -> UserDefinedTypeName .       (rule 20)

	"{"            reduce using rule 20
	","            reduce using rule 20


State 33

	UserDefinedTypeName -> ident .                      (rule 41)

	"public"       reduce using rule 41
	"internal"     reduce using rule 41
	"private"      reduce using rule 41
	"constant"     reduce using rule 41
	"{"            reduce using rule 41
	","            reduce using rule 41
	ident          reduce using rule 41


State 34

	ContractDefinition -> ConLibInt ident zero(InheritanceSpecList) "{" . list(ContractPart) "}"    (rule 14)

	"string"       shift, and enter state 43
	function       shift, and enter state 44
	"address"      shift, and enter state 45
	"bool"         shift, and enter state 46
	"var"          shift, and enter state 47
	"}"            reduce using rule 47
	ident          shift, and enter state 33

	ContractPart   goto state 35
	FunctionDefinitiongoto state 36
	StateVarDec    goto state 37
	TypeName       goto state 38
	UserDefinedTypeNamegoto state 39
	ElementaryTypeNamegoto state 40
	list(ContractPart)goto state 41
	list1(ContractPart)goto state 42

State 35

	list1(ContractPart) -> ContractPart .               (rule 58)
	list1(ContractPart) -> ContractPart . list1(ContractPart)    (rule 59)

	"string"       shift, and enter state 43
	function       shift, and enter state 44
	"address"      shift, and enter state 45
	"bool"         shift, and enter state 46
	"var"          shift, and enter state 47
	"}"            reduce using rule 58
	ident          shift, and enter state 33

	ContractPart   goto state 35
	FunctionDefinitiongoto state 36
	StateVarDec    goto state 37
	TypeName       goto state 38
	UserDefinedTypeNamegoto state 39
	ElementaryTypeNamegoto state 40
	list1(ContractPart)goto state 64

State 36

	ContractPart -> FunctionDefinition .                (rule 24)

	"string"       reduce using rule 24
	function       reduce using rule 24
	"address"      reduce using rule 24
	"bool"         reduce using rule 24
	"var"          reduce using rule 24
	"}"            reduce using rule 24
	ident          reduce using rule 24


State 37

	ContractPart -> StateVarDec .                       (rule 23)

	"string"       reduce using rule 23
	function       reduce using rule 23
	"address"      reduce using rule 23
	"bool"         reduce using rule 23
	"var"          reduce using rule 23
	"}"            reduce using rule 23
	ident          reduce using rule 23


State 38

	StateVarDec -> TypeName . zero(AssVar) ident zero(MExpression) ";"    (rule 27)

	"public"       shift, and enter state 60
	"internal"     shift, and enter state 61
	"private"      shift, and enter state 62
	"constant"     shift, and enter state 63
	ident          reduce using rule 53

	AssVar         goto state 58
	zero(AssVar)   goto state 59

State 39

	TypeName -> UserDefinedTypeName .                   (rule 29)

	"public"       reduce using rule 29
	"internal"     reduce using rule 29
	"private"      reduce using rule 29
	"constant"     reduce using rule 29
	ident          reduce using rule 29


State 40

	TypeName -> ElementaryTypeName .                    (rule 28)

	"public"       reduce using rule 28
	"internal"     reduce using rule 28
	"private"      reduce using rule 28
	"constant"     reduce using rule 28
	ident          reduce using rule 28


State 41

	ContractDefinition -> ConLibInt ident zero(InheritanceSpecList) "{" list(ContractPart) . "}"    (rule 14)

	"}"            shift, and enter state 57


State 42

	list(ContractPart) -> list1(ContractPart) .         (rule 46)

	"}"            reduce using rule 46


State 43

	ElementaryTypeName -> "string" .                    (rule 45)

	"public"       reduce using rule 45
	"internal"     reduce using rule 45
	"private"      reduce using rule 45
	"constant"     reduce using rule 45
	ident          reduce using rule 45


State 44

	FunctionDefinition -> function . ident Parameter ";"    (rule 25)

	ident          shift, and enter state 56


State 45

	ElementaryTypeName -> "address" .                   (rule 42)

	"public"       reduce using rule 42
	"internal"     reduce using rule 42
	"private"      reduce using rule 42
	"constant"     reduce using rule 42
	ident          reduce using rule 42


State 46

	ElementaryTypeName -> "bool" .                      (rule 43)

	"public"       reduce using rule 43
	"internal"     reduce using rule 43
	"private"      reduce using rule 43
	"constant"     reduce using rule 43
	ident          reduce using rule 43


State 47

	ElementaryTypeName -> "var" .                       (rule 44)

	"public"       reduce using rule 44
	"internal"     reduce using rule 44
	"private"      reduce using rule 44
	"constant"     reduce using rule 44
	ident          reduce using rule 44


State 48

	list1(OMInheritanceSpec) -> OMInheritanceSpec .     (rule 60)
	list1(OMInheritanceSpec) -> OMInheritanceSpec . list1(OMInheritanceSpec)    (rule 61)

	"{"            reduce using rule 60
	","            shift, and enter state 51

	OMInheritanceSpecgoto state 48
	list1(OMInheritanceSpec)goto state 55

State 49

	InheritanceSpecList -> "is" InheritanceSpecifier list(OMInheritanceSpec) .    (rule 18)

	"{"            reduce using rule 18


State 50

	list(OMInheritanceSpec) -> list1(OMInheritanceSpec) .    (rule 48)

	"{"            reduce using rule 48


State 51

	OMInheritanceSpec -> "," . InheritanceSpecifier     (rule 19)

	ident          shift, and enter state 33

	InheritanceSpecifiergoto state 54
	UserDefinedTypeNamegoto state 32

State 52

	ImportDirective -> "import" ImportAster ImportAs "from" stringLiteral . ";"    (rule 9)

	";"            shift, and enter state 53


State 53

	ImportDirective -> "import" ImportAster ImportAs "from" stringLiteral ";" .    (rule 9)

	"pragma"       reduce using rule 9
	"import"       reduce using rule 9
	contract       reduce using rule 9
	"library"      reduce using rule 9
	"interface"    reduce using rule 9
	%eof           reduce using rule 9


State 54

	OMInheritanceSpec -> "," InheritanceSpecifier .     (rule 19)

	"{"            reduce using rule 19
	","            reduce using rule 19


State 55

	list1(OMInheritanceSpec) -> OMInheritanceSpec list1(OMInheritanceSpec) .    (rule 61)

	"{"            reduce using rule 61


State 56

	FunctionDefinition -> function ident . Parameter ";"    (rule 25)

	ident          shift, and enter state 67

	Parameter      goto state 66

State 57

	ContractDefinition -> ConLibInt ident zero(InheritanceSpecList) "{" list(ContractPart) "}" .    (rule 14)

	"pragma"       reduce using rule 14
	"import"       reduce using rule 14
	contract       reduce using rule 14
	"library"      reduce using rule 14
	"interface"    reduce using rule 14
	%eof           reduce using rule 14


State 58

	zero(AssVar) -> AssVar .                            (rule 52)

	ident          reduce using rule 52


State 59

	StateVarDec -> TypeName zero(AssVar) . ident zero(MExpression) ";"    (rule 27)

	ident          shift, and enter state 65


State 60

	AssVar -> "public" .                                (rule 30)

	ident          reduce using rule 30


State 61

	AssVar -> "internal" .                              (rule 32)

	ident          reduce using rule 32


State 62

	AssVar -> "private" .                               (rule 31)

	ident          reduce using rule 31


State 63

	AssVar -> "constant" .                              (rule 33)

	ident          reduce using rule 33


State 64

	list1(ContractPart) -> ContractPart list1(ContractPart) .    (rule 59)

	"}"            reduce using rule 59


State 65

	StateVarDec -> TypeName zero(AssVar) ident . zero(MExpression) ";"    (rule 27)

	"="            shift, and enter state 71
	";"            reduce using rule 57

	MExpression    goto state 69
	zero(MExpression)goto state 70

State 66

	FunctionDefinition -> function ident Parameter . ";"    (rule 25)

	";"            shift, and enter state 68


State 67

	Parameter -> ident .                                (rule 26)

	";"            reduce using rule 26


State 68

	FunctionDefinition -> function ident Parameter ";" .    (rule 25)

	"string"       reduce using rule 25
	function       reduce using rule 25
	"address"      reduce using rule 25
	"bool"         reduce using rule 25
	"var"          reduce using rule 25
	"}"            reduce using rule 25
	ident          reduce using rule 25


State 69

	zero(MExpression) -> MExpression .                  (rule 56)

	";"            reduce using rule 56


State 70

	StateVarDec -> TypeName zero(AssVar) ident zero(MExpression) . ";"    (rule 27)

	";"            shift, and enter state 77


State 71

	MExpression -> "=" . Expression                     (rule 36)

	"true"         shift, and enter state 75
	"false"        shift, and enter state 76

	Expression     goto state 72
	PrimaryExpressiongoto state 73
	BooleanLiteral goto state 74

State 72

	MExpression -> "=" Expression .                     (rule 36)

	";"            reduce using rule 36


State 73

	Expression -> PrimaryExpression .                   (rule 37)

	";"            reduce using rule 37


State 74

	PrimaryExpression -> BooleanLiteral .               (rule 38)

	";"            reduce using rule 38


State 75

	BooleanLiteral -> "true" .                          (rule 39)

	";"            reduce using rule 39


State 76

	BooleanLiteral -> "false" .                         (rule 40)

	";"            reduce using rule 40


State 77

	StateVarDec -> TypeName zero(AssVar) ident zero(MExpression) ";" .    (rule 27)

	"string"       reduce using rule 27
	function       reduce using rule 27
	"address"      reduce using rule 27
	"bool"         reduce using rule 27
	"var"          reduce using rule 27
	"}"            reduce using rule 27
	ident          reduce using rule 27


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 62
Number of terminals: 52
Number of non-terminals: 36
Number of states: 78
